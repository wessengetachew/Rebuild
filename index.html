
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Modulus Modular Arithmetic Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        #header {
            background: #2a2a2a;
            padding: 15px 20px;
            border-bottom: 2px solid #3a3a3a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-size: 24px;
            font-weight: 600;
        }

        #mainContainer {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        #canvasContainer {
            flex: 1;
            position: relative;
            background: #0a0a0a;
            overflow: hidden;
        }

        #canvas {
            cursor: crosshair;
            display: block;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(30, 30, 30, 0.95);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            border: 1px solid #444;
        }

        #legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(30, 30, 30, 0.95);
            padding: 15px;
            border-radius: 8px;
            max-width: 250px;
            border: 1px solid #444;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }

        #zoomControls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(30, 30, 30, 0.95);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #444;
            display: flex;
            gap: 10px;
        }

        #detailsPanel {
            background: #2a2a2a;
            padding: 20px;
            border-top: 2px solid #3a3a3a;
            max-height: 200px;
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #3a3a3a;
        }

        .control-group:last-child {
            border-bottom: none;
        }

        .control-group h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #4a9eff;
            font-weight: 600;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #b0b0b0;
        }

        input[type="number"], select {
            width: 100%;
            padding: 6px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 12px;
        }

        input[type="range"] {
            width: 100%;
            margin: 8px 0;
        }

        input[type="checkbox"] {
            margin-right: 8px;
        }

        button {
            padding: 8px 16px;
            background: #4a9eff;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background 0.2s;
        }

        button:hover {
            background: #3a8eef;
        }

        button:active {
            background: #2a7edf;
        }

        .btn-secondary {
            background: #555;
        }

        .btn-secondary:hover {
            background: #666;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 11px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 8px;
            border: 1px solid #666;
        }

        .details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .detail-item {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #3a3a3a;
        }

        .detail-label {
            font-size: 11px;
            color: #888;
            margin-bottom: 4px;
        }

        .detail-value {
            font-size: 14px;
            font-weight: 600;
            color: #4a9eff;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            display: none;
            border: 1px solid #4a9eff;
            z-index: 1000;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 10px;
        }

        .preset-btn {
            padding: 6px;
            font-size: 11px;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .inline-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 5px;
        }

        .inline-controls input[type="number"] {
            width: 60px;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>Multi-Modulus Modular Arithmetic Explorer</h1>
        <button onclick="exportVisualization()">Export High-Res (4K)</button>
    </div>

    <div id="mainContainer">
        <div id="canvasContainer">
            <canvas id="canvas"></canvas>
            
            <div id="controls">
                <div class="control-group">
                    <h3>Multi-Modulus Configuration</h3>
                    <label>
                        <input type="checkbox" id="multiModusEnabled" checked> Enable Multi-Modulus Mode
                    </label>
                    <label>Mode Type:</label>
                    <select id="modeType">
                        <option value="consecutive">Consecutive (1 to n)</option>
                        <option value="composite">Composite Only</option>
                        <option value="primes">Primes Only</option>
                    </select>
                    <div class="inline-controls">
                        <div style="flex: 1;">
                            <label>Start:</label>
                            <input type="number" id="startM" value="1" min="1" max="200">
                        </div>
                        <div style="flex: 1;">
                            <label>End:</label>
                            <input type="number" id="endM" value="30" min="1" max="200">
                        </div>
                    </div>
                    <div class="preset-buttons">
                        <button class="preset-btn" onclick="setPreset('first12')">First 12</button>
                        <button class="preset-btn" onclick="setPreset('first30')">First 30</button>
                        <button class="preset-btn" onclick="setPreset('first60')">First 60</button>
                        <button class="preset-btn" onclick="setPreset('twin')">Twin Range</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>Connection Types</h3>
                    <label>
                        <input type="checkbox" id="showRtoR" checked> r-to-r Connections (Vertical)
                    </label>
                    <label>
                        <input type="checkbox" id="showRtoRplusM"> r-to-r+M Connections (Modular)
                    </label>
                    <label>
                        <input type="checkbox" id="showGapConnections"> r-to-r+2n Gaps (Within Ring)
                    </label>
                    <div id="gapControls">
                        <label>Gap Size (n): <span id="gapValue">1</span> → Connects r to r+<span id="actualGap">2</span></label>
                        <input type="range" id="gapSize" min="1" max="20" value="1">
                        <div class="preset-buttons">
                            <button class="preset-btn" onclick="setGap(1)">Twin (n=1)</button>
                            <button class="preset-btn" onclick="setGap(2)">Cousin (n=2)</button>
                            <button class="preset-btn" onclick="setGap(3)">Sexy (n=3)</button>
                            <button class="preset-btn" onclick="setGap(4)">Gap-8 (n=4)</button>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <h3>Point Labeling</h3>
                    <label>
                        <input type="checkbox" id="showLabels"> Show Labels
                    </label>
                    <label>Label Mode:</label>
                    <select id="labelMode">
                        <option value="residue">Residue (r)</option>
                        <option value="fraction">Fraction (r/M)</option>
                        <option value="gcd">GCD Value</option>
                        <option value="channel">Channel (M')</option>
                        <option value="degrees">Angle (degrees)</option>
                        <option value="radians">Angle (radians)</option>
                        <option value="formula">Formula (2πr/M)</option>
                        <option value="position">Position (r, M)</option>
                    </select>
                    <label>
                        <input type="checkbox" id="coprimeOnly"> Coprime Only
                    </label>
                </div>

                <div class="control-group">
                    <h3>Visual Settings</h3>
                    <label>Color Scheme:</label>
                    <select id="colorScheme">
                        <option value="coprime">Coprime/Non-Coprime</option>
                        <option value="gcd">By GCD Value</option>
                        <option value="modulus">By Modulus</option>
                        <option value="rainbow">Rainbow</option>
                    </select>
                    <label>Point Size:</label>
                    <input type="range" id="pointSize" min="2" max="10" value="4">
                </div>

                <button onclick="render()" style="width: 100%; margin-top: 10px;">Update Visualization</button>
            </div>

            <div id="legend">
                <h3 style="margin-bottom: 10px; font-size: 14px;">Legend</h3>
                <div id="legendContent"></div>
            </div>

            <div id="zoomControls">
                <button onclick="zoomIn()">Zoom In (+)</button>
                <button onclick="zoomOut()">Zoom Out (-)</button>
                <button onclick="resetView()">Reset View</button>
            </div>

            <div class="tooltip" id="tooltip"></div>
        </div>
    </div>

    <div id="detailsPanel">
        <h3 style="margin-bottom: 15px; font-size: 16px;">Current Parameters & Statistics</h3>
        <div class="details-grid" id="detailsGrid"></div>
    </div>

    <script>
        // Canvas and rendering state
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        // Data structures
        let points = [];
        let connections = [];
        let currentStats = {};

        // Resize canvas
        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            render();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Prime checking
        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i <= Math.sqrt(n); i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }

        // GCD calculation
        function gcd(a, b) {
            while (b !== 0) {
                let temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }

        // Euler's totient function
        function eulerTotient(n) {
            let result = n;
            for (let p = 2; p * p <= n; p++) {
                if (n % p === 0) {
                    while (n % p === 0) n /= p;
                    result -= result / p;
                }
            }
            if (n > 1) result -= result / n;
            return Math.round(result);
        }

        // Get moduli based on configuration
        function getModuli() {
            const start = parseInt(document.getElementById('startM').value);
            const end = parseInt(document.getElementById('endM').value);
            const mode = document.getElementById('modeType').value;
            const moduli = [];

            for (let m = start; m <= end; m++) {
                if (mode === 'consecutive') {
                    moduli.push(m);
                } else if (mode === 'composite' && !isPrime(m) && m > 1) {
                    moduli.push(m);
                } else if (mode === 'primes' && isPrime(m)) {
                    moduli.push(m);
                }
            }

            return moduli;
        }

        // Generate points
        function generatePoints() {
            points = [];
            const moduli = getModuli();
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.min(canvas.width, canvas.height) * 0.4;
            const radiusStep = maxRadius / (moduli.length + 1);

            moduli.forEach((M, ringIndex) => {
                const radius = radiusStep * (ringIndex + 1);
                
                for (let r = 0; r < M; r++) {
                    const angle = (2 * Math.PI * r) / M - Math.PI / 2;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    const g = gcd(r, M);
                    const isCoprime = g === 1;
                    const channel = M / g;

                    points.push({
                        x, y, r, M, g, isCoprime, channel, angle, radius, ringIndex
                    });
                }
            });
        }

        // Generate connections
        function generateConnections() {
            connections = [];
            const moduli = getModuli();

            // r-to-r connections
            if (document.getElementById('showRtoR').checked) {
                for (let i = 0; i < moduli.length - 1; i++) {
                    const M1 = moduli[i];
                    const M2 = moduli[i + 1];
                    
                    for (let r = 0; r < Math.min(M1, M2); r++) {
                        const p1 = points.find(p => p.M === M1 && p.r === r);
                        const p2 = points.find(p => p.M === M2 && p.r === r);
                        
                        if (p1 && p2 && p1.isCoprime && p2.isCoprime) {
                            connections.push({ p1, p2, type: 'rtor' });
                        }
                    }
                }
            }

            // Gap connections
            if (document.getElementById('showGapConnections').checked) {
                const n = parseInt(document.getElementById('gapSize').value);
                const gap = 2 * n;

                moduli.forEach(M => {
                    const ringPoints = points.filter(p => p.M === M);
                    
                    ringPoints.forEach(p1 => {
                        const r2 = (p1.r + gap) % M;
                        const p2 = ringPoints.find(p => p.r === r2);
                        
                        if (p2 && p1.isCoprime && p2.isCoprime) {
                            connections.push({ p1, p2, type: 'gap', gap });
                        }
                    });
                });
            }

            // r-to-r+M connections
            if (document.getElementById('showRtoRplusM').checked) {
                for (let i = 0; i < moduli.length - 1; i++) {
                    const M1 = moduli[i];
                    const M2 = moduli[i + 1];
                    
                    for (let r = 0; r < M1; r++) {
                        const p1 = points.find(p => p.M === M1 && p.r === r);
                        const r2 = (r + M1) % M2;
                        const p2 = points.find(p => p.M === M2 && p.r === r2);
                        
                        if (p1 && p2) {
                            connections.push({ p1, p2, type: 'rtorplusm' });
                        }
                    }
                }
            }
        }

        // Get point color
        function getPointColor(point) {
            const scheme = document.getElementById('colorScheme').value;
            
            if (scheme === 'coprime') {
                return point.isCoprime ? '#4a9eff' : '#ff4a4a';
            } else if (scheme === 'gcd') {
                const hue = (point.g * 40) % 360;
                return `hsl(${hue}, 70%, 60%)`;
            } else if (scheme === 'modulus') {
                const hue = (point.M * 10) % 360;
                return `hsl(${hue}, 70%, 60%)`;
            } else if (scheme === 'rainbow') {
                const hue = (point.angle / (2 * Math.PI)) * 360;
                return `hsl(${hue}, 70%, 60%)`;
            }
        }

        // Get connection color
        function getConnectionColor(conn) {
            if (conn.type === 'rtor') return 'rgba(74, 158, 255, 0.3)';
            if (conn.type === 'gap') return 'rgba(255, 74, 74, 0.3)';
            if (conn.type === 'rtorplusm') return 'rgba(74, 255, 158, 0.3)';
        }

        // Transform coordinates
        function transform(x, y) {
            return {
                x: (x - canvas.width / 2) * scale + canvas.width / 2 + offsetX,
                y: (y - canvas.height / 2) * scale + canvas.height / 2 + offsetY
            };
        }

        function inverseTransform(x, y) {
            return {
                x: (x - offsetX - canvas.width / 2) / scale + canvas.width / 2,
                y: (y - offsetY - canvas.height / 2) / scale + canvas.height / 2
            };
        }

        // Render visualization
        function render() {
            generatePoints();
            generateConnections();
            updateStatistics();
            updateLegend();
            draw();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw connections
            connections.forEach(conn => {
                const p1 = transform(conn.p1.x, conn.p1.y);
                const p2 = transform(conn.p2.x, conn.p2.y);
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.strokeStyle = getConnectionColor(conn);
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Draw points
            const pointSize = parseInt(document.getElementById('pointSize').value);
            const coprimeOnly = document.getElementById('coprimeOnly').checked;
            
            points.forEach(point => {
                if (coprimeOnly && !point.isCoprime) return;
                
                const p = transform(point.x, point.y);
                ctx.beginPath();
                ctx.arc(p.x, p.y, pointSize, 0, 2 * Math.PI);
                ctx.fillStyle = getPointColor(point);
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 0.5;
                ctx.stroke();
            });

            // Draw labels
            if (document.getElementById('showLabels').checked) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                points.forEach(point => {
                    if (coprimeOnly && !point.isCoprime) return;
                    
                    const p = transform(point.x, point.y);
                    const label = getLabel(point);
                    ctx.fillText(label, p.x, p.y - pointSize - 5);
                });
            }
        }

        // Get label text
        function getLabel(point) {
            const mode = document.getElementById('labelMode').value;
            
            switch (mode) {
                case 'residue': return point.r;
                case 'fraction': return `${point.r}/${point.M}`;
                case 'gcd': return point.g;
                case 'channel': return point.channel;
                case 'degrees': return `${Math.round((point.angle + Math.PI/2) * 180 / Math.PI)}°`;
                case 'radians': return `${((point.angle + Math.PI/2) / Math.PI).toFixed(2)}π`;
                case 'formula': return `2π(${point.r})/${point.M}`;
                case 'position': return `(${point.r},${point.M})`;
                default: return point.r;
            }
        }

        // Update statistics
        function updateStatistics() {
            const moduli = getModuli();
            const totalPoints = points.length;
            const coprimePoints = points.filter(p => p.isCoprime).length;
            const totalModuli = moduli.length;
            const avgDensity = (coprimePoints / totalPoints * 100).toFixed(1);
            const primeCount = moduli.filter(m => isPrime(m)).length;
            const compositeCount = totalModuli - primeCount;

            currentStats = {
                'Total Moduli': totalModuli,
                'Total Points': totalPoints,
                'Coprime Points': coprimePoints,
                'Average Density': `${avgDensity}%`,
                'Prime Count': primeCount,
                'Composite Count': compositeCount,
                'Total Connections': connections.length,
                'Modulus Range': `${moduli[0]} - ${moduli[moduli.length - 1]}`
            };

            const grid = document.getElementById('detailsGrid');
            grid.innerHTML = '';
            
            for (const [label, value] of Object.entries(currentStats)) {
                const item = document.createElement('div');
                item.className = 'detail-item';
                item.innerHTML = `
                    <div class="detail-label">${label}</div>
                    <div class="detail-value">${value}</div>
                `;
                grid.appendChild(item);
            }
        }

        // Update legend
        function updateLegend() {
            const scheme = document.getElementById('colorScheme').value;
            const legendContent = document.getElementById('legendContent');
            legendContent.innerHTML = '';

            if (scheme === 'coprime') {
                legendContent.innerHTML = `
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4a9eff;"></div>
                        <span>Coprime (gcd = 1)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff4a4a;"></div>
                        <span>Non-Coprime (gcd > 1)</span>
                    </div>
                `;
            } else if (scheme === 'gcd') {
                legendContent.innerHTML = '<div style="font-size: 11px; margin-bottom: 8px;">Color by GCD Value</div>';
                for (let g = 1; g <= 5; g++) {
                    const hue = (g * 40) % 360;
                    const color = `hsl(${hue}, 70%, 60%)`;
                    legendContent.innerHTML += `
                        <div class="legend-item">
                            <div class="legend-color" style="background: ${color};"></div>
                            <span>gcd = ${g}</span>
                        </div>
                    `;
                }
            } else if (scheme === 'modulus') {
                legendContent.innerHTML = '<div style="font-size: 11px; margin-bottom: 8px;">Color by Modulus</div>';
                const moduli = getModuli();
                const samples = moduli.filter((m, i) => i % Math.max(1, Math.floor(moduli.length / 5)) === 0);
                samples.forEach(m => {
                    const hue = (m * 10) % 360;
                    const color = `hsl(${hue}, 70%, 60%)`;
                    legendContent.innerHTML += `
                        <div class="legend-item">
                            <div class="legend-color" style="background: ${color};"></div>
                            <span>M = ${m}</span>
                        </div>
                    `;
                });
            } else if (scheme === 'rainbow') {
                legendContent.innerHTML = '<div style="font-size: 11px; margin-bottom: 8px;">Color by Angle</div>';
            }

            // Add connection types
            if (connections.length > 0) {
                legendContent.innerHTML += '<hr style="margin: 10px 0; border-color: #444;">';
                legendContent.innerHTML += '<div style="font-size: 11px; margin-bottom: 8px;">Connections</div>';
                
                if (connections.some(c => c.type === 'rtor')) {
                    legendContent.innerHTML += `
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(74, 158, 255, 0.5);"></div>
                            <span>r-to-r (Vertical)</span>
                        </div>
                    `;
                }
                if (connections.some(c => c.type === 'gap')) {
                    legendContent.innerHTML += `
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(255, 74, 74, 0.5);"></div>
                            <span>Gap Connections</span>
                        </div>
                    `;
                }
                if (connections.some(c => c.type === 'rtorplusm')) {
                    legendContent.innerHTML += `
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(74, 255, 158, 0.5);"></div>
                            <span>r-to-r+M (Modular)</span>
                        </div>
                    `;
                }
            }
        }

        // Zoom and pan controls
        function zoomIn() {
            scale *= 1.2;
            draw();
        }

        function zoomOut() {
            scale /= 1.2;
            draw();
        }

        function resetView() {
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            draw();
        }

        // Mouse interaction
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                offsetX += e.clientX - lastX;
                offsetY += e.clientY - lastY;
                lastX = e.clientX;
                lastY = e.clientY;
                draw();
            } else {
                showTooltip(e);
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoom = e.deltaY < 0 ? 1.1 : 0.9;
            scale *= zoom;
            draw();
        });

        // Tooltip
        function showTooltip(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const invPoint = inverseTransform(mouseX, mouseY);
            
            const pointSize = parseInt(document.getElementById('pointSize').value);
            const nearestPoint = points.find(p => {
                const dx = p.x - invPoint.x;
                const dy = p.y - invPoint.y;
                return Math.sqrt(dx * dx + dy * dy) < pointSize + 5;
            });

            const tooltip = document.getElementById('tooltip');
            
            if (nearestPoint) {
                const angleDeg = Math.round((nearestPoint.angle + Math.PI/2) * 180 / Math.PI);
                tooltip.innerHTML = `
                    <strong>Point Details</strong><br>
                    Modulus M: ${nearestPoint.M}<br>
                    Residue r: ${nearestPoint.r}<br>
                    GCD(r, M): ${nearestPoint.g}<br>
                    Coprime: ${nearestPoint.isCoprime ? 'Yes' : 'No'}<br>
                    Channel M': ${nearestPoint.channel}<br>
                    Angle: ${angleDeg}° (${(nearestPoint.angle + Math.PI/2).toFixed(3)} rad)<br>
                    Formula: 2π(${nearestPoint.r})/${nearestPoint.M}
                `;
                tooltip.style.left = (e.clientX + 10) + 'px';
                tooltip.style.top = (e.clientY + 10) + 'px';
                tooltip.style.display = 'block';
            } else {
                tooltip.style.display = 'none';
            }
        }

        canvas.addEventListener('mouseleave', () => {
            document.getElementById('tooltip').style.display = 'none';
        });

        // Preset functions
        function setPreset(preset) {
            const startM = document.getElementById('startM');
            const endM = document.getElementById('endM');
            
            switch (preset) {
                case 'first12':
                    startM.value = 1;
                    endM.value = 12;
                    break;
                case 'first30':
                    startM.value = 1;
                    endM.value = 30;
                    break;
                case 'first60':
                    startM.value = 1;
                    endM.value = 60;
                    break;
                case 'twin':
                    startM.value = 1;
                    endM.value = 100;
                    document.getElementById('showGapConnections').checked = true;
                    document.getElementById('gapSize').value = 1;
                    break;
            }
            render();
        }

        function setGap(n) {
            document.getElementById('gapSize').value = n;
            document.getElementById('gapValue').textContent = n;
            document.getElementById('actualGap').textContent = 2 * n;
            render();
        }

        // Gap slider update
        document.getElementById('gapSize').addEventListener('input', (e) => {
            const n = e.target.value;
            document.getElementById('gapValue').textContent = n;
            document.getElementById('actualGap').textContent = 2 * n;
        });

        // Export function
        function exportVisualization() {
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = 3840;  // 4K width
            exportCanvas.height = 2160; // 4K height
            const exportCtx = exportCanvas.getContext('2d');
            
            // Save current canvas state
            const savedWidth = canvas.width;
            const savedHeight = canvas.height;
            const savedScale = scale;
            const savedOffsetX = offsetX;
            const savedOffsetY = offsetY;
            
            // Set up for export
            canvas.width = 3840;
            canvas.height = 2160;
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            
            // Regenerate and draw
            generatePoints();
            generateConnections();
            draw();
            
            // Copy to export canvas
            exportCtx.drawImage(canvas, 0, 0);
            
            // Add title and subtitle
            exportCtx.fillStyle = '#ffffff';
            exportCtx.font = 'bold 60px Arial';
            exportCtx.textAlign = 'center';
            const moduli = getModuli();
            const title = `Multi-Modulus Visualization: M = ${moduli[0]} to ${moduli[moduli.length - 1]}`;
            exportCtx.fillText(title, exportCanvas.width / 2, 80);
            
            exportCtx.font = '40px Arial';
            const mode = document.getElementById('modeType').value;
            const subtitle = `Mode: ${mode} | Total Points: ${points.length} | Coprime: ${points.filter(p => p.isCoprime).length}`;
            exportCtx.fillText(subtitle, exportCanvas.width / 2, 140);
            
            // Download
            exportCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `multi_modulus_M${moduli[0]}-${moduli[moduli.length - 1]}_${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
            
            // Restore canvas state
            canvas.width = savedWidth;
            canvas.height = savedHeight;
            scale = savedScale;
            offsetX = savedOffsetX;
            offsetY = savedOffsetY;
            draw();
        }

        // Initial render
        render();
    </script>
</body>
</html>
